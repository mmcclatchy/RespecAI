from fastmcp import Context, FastMCP
from fastmcp.exceptions import ResourceError, ToolError
from pydantic import ValidationError

from services.models.spec import TechnicalSpec
from services.shared import state_manager
from services.utils.enums import LoopStatus
from services.utils.errors import LoopNotFoundError, RoadmapNotFoundError, SpecNotFoundError
from services.utils.loop_state import MCPResponse
from services.utils.state_manager import StateManager


class SpecTools:
    def __init__(self, state: StateManager) -> None:
        self.state = state

    def store_spec(self, project_path: str, spec_name: str, spec_markdown: str) -> str:
        if not project_path:
            raise ToolError('Project path cannot be empty')
        if not spec_name:
            raise ToolError('Spec name cannot be empty')
        if not spec_markdown:
            raise ToolError('Spec markdown cannot be empty')

        try:
            spec = TechnicalSpec.parse_markdown(spec_markdown)
            self.state.store_spec(project_path, spec)
            return f'Stored spec "{spec_name}" in project {project_path} (iteration {spec.iteration}, version {spec.version})'
        except RoadmapNotFoundError as e:
            raise ResourceError(str(e))
        except ValidationError:
            raise ToolError('Invalid specification data provided')
        except Exception as e:
            raise ToolError(f'Failed to store spec: {str(e)}')

    def get_spec_markdown(self, project_path: str | None, spec_name: str | None, loop_id: str | None) -> MCPResponse:
        try:
            if loop_id:
                loop_state = self.state.get_loop(loop_id)
                spec = self.state.get_spec_by_loop(loop_id)
                markdown = spec.build_markdown()
                return MCPResponse(id=loop_id, status=loop_state.status, message=markdown)
            elif project_path and spec_name:
                spec = self.state.get_spec(project_path, spec_name)
                markdown = spec.build_markdown()
                return MCPResponse(id=f'{project_path}/{spec_name}', status=LoopStatus.COMPLETED, message=markdown)
            else:
                raise ToolError('Either loop_id OR (project_path AND spec_name) must be provided')
        except LoopNotFoundError:
            raise ResourceError('Loop does not exist or is not linked to a spec')
        except RoadmapNotFoundError as e:
            raise ResourceError(str(e))
        except SpecNotFoundError as e:
            raise ResourceError(str(e))
        except Exception as e:
            raise ToolError(f'Failed to retrieve spec: {str(e)}')

    def list_specs(self, project_path: str) -> MCPResponse:
        if not project_path:
            raise ToolError('Project path cannot be empty')

        try:
            spec_names = self.state.list_specs(project_path)
            if not spec_names:
                return MCPResponse(
                    id=project_path, status=LoopStatus.COMPLETED, message=f'No specs found in project {project_path}'
                )

            spec_list = ', '.join(spec_names)
            return MCPResponse(
                id=project_path,
                status=LoopStatus.COMPLETED,
                message=f'Found {len(spec_names)} spec{"s" if len(spec_names) != 1 else ""} in project {project_path}: {spec_list}',
            )
        except RoadmapNotFoundError as e:
            raise ResourceError(str(e))
        except Exception as e:
            raise ToolError(f'Failed to list specs: {str(e)}')

    def delete_spec(self, project_path: str, spec_name: str) -> MCPResponse:
        if not project_path:
            raise ToolError('Project path cannot be empty')
        if not spec_name:
            raise ToolError('Spec name cannot be empty')

        try:
            was_deleted = self.state.delete_spec(project_path, spec_name)
            if was_deleted:
                return MCPResponse(
                    id=f'{project_path}/{spec_name}',
                    status=LoopStatus.COMPLETED,
                    message=f'Deleted spec "{spec_name}" from project {project_path}',
                )
            else:
                return MCPResponse(
                    id=f'{project_path}/{spec_name}',
                    status=LoopStatus.COMPLETED,
                    message=f'Spec "{spec_name}" not found in project {project_path}',
                )
        except RoadmapNotFoundError as e:
            raise ResourceError(str(e))
        except Exception as e:
            raise ToolError(f'Failed to delete spec: {str(e)}')

    def link_loop_to_spec(self, loop_id: str, project_path: str, spec_name: str) -> MCPResponse:
        if not loop_id:
            raise ToolError('Loop ID cannot be empty')
        if not project_path:
            raise ToolError('Project path cannot be empty')
        if not spec_name:
            raise ToolError('Spec name cannot be empty')

        try:
            self.state.link_loop_to_spec(loop_id, project_path, spec_name)
            loop_state = self.state.get_loop(loop_id)
            return MCPResponse(
                id=loop_id,
                status=loop_state.status,
                message=f'Linked loop {loop_id} to spec "{spec_name}" in project {project_path}',
            )
        except SpecNotFoundError as e:
            raise ResourceError(str(e))
        except LoopNotFoundError:
            raise ResourceError('Loop does not exist')
        except Exception as e:
            raise ToolError(f'Failed to link loop to spec: {str(e)}')

    def unlink_loop(self, loop_id: str) -> MCPResponse:
        if not loop_id:
            raise ToolError('Loop ID cannot be empty')

        try:
            result = self.state.unlink_loop(loop_id)
            loop_state = self.state.get_loop(loop_id)
            if result:
                project_id, spec_name = result
                return MCPResponse(
                    id=loop_id,
                    status=loop_state.status,
                    message=f'Unlinked loop {loop_id} from spec "{spec_name}" in project {project_id}',
                )
            else:
                return MCPResponse(
                    id=loop_id, status=loop_state.status, message=f'Loop {loop_id} was not linked to any spec'
                )
        except LoopNotFoundError:
            raise ResourceError('Loop does not exist')
        except Exception as e:
            raise ToolError(f'Failed to unlink loop: {str(e)}')


def register_spec_tools(mcp: FastMCP) -> None:
    spec_tools = SpecTools(state_manager)

    @mcp.tool()
    async def store_spec(project_path: str, spec_name: str, spec_markdown: str, ctx: Context) -> str:
        """Store technical specification with automatic versioning.

        Parses markdown content into a TechnicalSpec model and stores it in the
        unified spec storage. Automatically increments iteration and version if
        updating an existing spec.

        Parameters:
        - project_path: Absolute path to project directory
        - spec_name: Name/phase of the specification
        - spec_markdown: Complete specification in markdown format

        Returns:
        - str: Confirmation message with iteration and version
        """
        await ctx.info(f'Storing spec "{spec_name}" for project {project_path}')
        try:
            result = spec_tools.store_spec(project_path, spec_name, spec_markdown)
            await ctx.info(f'Stored spec "{spec_name}" for project {project_path}')
            return result
        except Exception as e:
            await ctx.error(f'Failed to store spec: {str(e)}')
            raise

    @mcp.tool()
    async def get_spec_markdown(
        project_path: str | None, spec_name: str | None, loop_id: str | None, ctx: Context
    ) -> MCPResponse:
        """Retrieve specification as markdown.

        Two retrieval modes:
        1. By loop_id: Retrieves spec linked to active refinement loop
        2. By project_path + spec_name: Retrieves spec directly from storage

        Parameters:
        - project_path: Absolute path to project directory (required if not using loop_id)
        - spec_name: Spec name (required if not using loop_id)
        - loop_id: Loop identifier (alternative to project_path + spec_name)

        Returns:
        - MCPResponse: Contains spec markdown in message field
        """
        await ctx.info('Retrieving spec markdown')
        try:
            result = spec_tools.get_spec_markdown(project_path, spec_name, loop_id)
            await ctx.info('Retrieved spec markdown')
            return result
        except Exception as e:
            await ctx.error(f'Failed to retrieve spec: {str(e)}')
            raise

    @mcp.tool()
    async def list_specs(project_path: str, ctx: Context) -> MCPResponse:
        """List all specifications for a project.

        Parameters:
        - project_path: Absolute path to project directory

        Returns:
        - MCPResponse: Contains list of spec names in message field
        """
        await ctx.info(f'Listing specs for project {project_path}')
        try:
            result = spec_tools.list_specs(project_path)
            await ctx.info(f'Listed specs for project {project_path}')
            return result
        except Exception as e:
            await ctx.error(f'Failed to list specs: {str(e)}')
            raise

    @mcp.tool()
    async def delete_spec(project_path: str, spec_name: str, ctx: Context) -> MCPResponse:
        """Delete a specification from storage.

        Parameters:
        - project_path: Absolute path to project directory
        - spec_name: Spec name to delete

        Returns:
        - MCPResponse: Contains deletion confirmation
        """
        await ctx.info(f'Deleting spec "{spec_name}" from project {project_path}')
        try:
            result = spec_tools.delete_spec(project_path, spec_name)
            await ctx.info(f'Deleted spec "{spec_name}" from project {project_path}')
            return result
        except Exception as e:
            await ctx.error(f'Failed to delete spec: {str(e)}')
            raise

    @mcp.tool()
    async def link_loop_to_spec(loop_id: str, project_path: str, spec_name: str, ctx: Context) -> MCPResponse:
        """Link active refinement loop to specification for idempotent iteration.

        Creates temporary mapping allowing agents to retrieve/update specs via loop_id
        during refinement sessions. Enables idempotent spec-architect pattern.

        Parameters:
        - loop_id: Active loop identifier
        - project_path: Absolute path to project directory
        - spec_name: Spec name to link

        Returns:
        - MCPResponse: Contains linking confirmation
        """
        await ctx.info(f'Linking loop {loop_id} to spec "{spec_name}" in project {project_path}')
        try:
            result = spec_tools.link_loop_to_spec(loop_id, project_path, spec_name)
            await ctx.info(f'Linked loop {loop_id} to spec')
            return result
        except Exception as e:
            await ctx.error(f'Failed to link loop to spec: {str(e)}')
            raise

    @mcp.tool()
    async def unlink_loop(loop_id: str, ctx: Context) -> MCPResponse:
        """Remove loop-to-spec mapping after refinement completion.

        Cleans up temporary mapping when refinement loop completes.

        Parameters:
        - loop_id: Loop identifier to unlink

        Returns:
        - MCPResponse: Contains unlinking confirmation
        """
        await ctx.info(f'Unlinking loop {loop_id}')
        try:
            result = spec_tools.unlink_loop(loop_id)
            await ctx.info(f'Unlinked loop {loop_id}')
            return result
        except Exception as e:
            await ctx.error(f'Failed to unlink loop: {str(e)}')
            raise
